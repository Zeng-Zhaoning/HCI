{"remainingRequest":"C:\\Users\\Zhaoning\\Desktop\\HCI\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\Zhaoning\\Desktop\\HCI\\node_modules\\@vue\\cli-service\\node_modules\\vue-loader-v16\\dist\\templateLoader.js??ref--6!C:\\Users\\Zhaoning\\Desktop\\HCI\\node_modules\\cache-loader\\dist\\cjs.js??ref--0-0!C:\\Users\\Zhaoning\\Desktop\\HCI\\node_modules\\@vue\\cli-service\\node_modules\\vue-loader-v16\\dist\\index.js??ref--0-1!C:\\Users\\Zhaoning\\Desktop\\HCI\\src\\components\\CytoscapeKG.vue?vue&type=template&id=3bc96091","dependencies":[{"path":"C:\\Users\\Zhaoning\\Desktop\\HCI\\src\\components\\CytoscapeKG.vue","mtime":1636257970944},{"path":"C:\\Users\\Zhaoning\\Desktop\\HCI\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\Zhaoning\\Desktop\\HCI\\node_modules\\babel-loader\\lib\\index.js","mtime":315532800000},{"path":"C:\\Users\\Zhaoning\\Desktop\\HCI\\node_modules\\@vue\\cli-service\\node_modules\\vue-loader-v16\\dist\\templateLoader.js","mtime":1616796459000},{"path":"C:\\Users\\Zhaoning\\Desktop\\HCI\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\Zhaoning\\Desktop\\HCI\\node_modules\\@vue\\cli-service\\node_modules\\vue-loader-v16\\dist\\index.js","mtime":1616796459000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qcyI7CmltcG9ydCB7IGNyZWF0ZUNvbW1lbnRWTm9kZSBhcyBfY3JlYXRlQ29tbWVudFZOb2RlLCByZXNvbHZlQ29tcG9uZW50IGFzIF9yZXNvbHZlQ29tcG9uZW50LCBjcmVhdGVWTm9kZSBhcyBfY3JlYXRlVk5vZGUsIHdpdGhDdHggYXMgX3dpdGhDdHgsIHJlbmRlckxpc3QgYXMgX3JlbmRlckxpc3QsIEZyYWdtZW50IGFzIF9GcmFnbWVudCwgb3BlbkJsb2NrIGFzIF9vcGVuQmxvY2ssIGNyZWF0ZUJsb2NrIGFzIF9jcmVhdGVCbG9jaywgY3JlYXRlVGV4dFZOb2RlIGFzIF9jcmVhdGVUZXh0Vk5vZGUgfSBmcm9tICJ2dWUiOwp2YXIgX2hvaXN0ZWRfMSA9IHsKICBjbGFzczogImtub3dsZWRnZS1ncmFwaC1jeSIKfTsKdmFyIF9ob2lzdGVkXzIgPSB7CiAgaWQ6ICJncmFwaCIKfTsKdmFyIF9ob2lzdGVkXzMgPSB7CiAgY2xhc3M6ICJkaWFsb2ctZm9vdGVyIgp9OwoKdmFyIF9ob2lzdGVkXzQgPSAvKiNfX1BVUkVfXyovX2NyZWF0ZVRleHRWTm9kZSgi5Y+WIOa2iCIpOwoKdmFyIF9ob2lzdGVkXzUgPSAvKiNfX1BVUkVfXyovX2NyZWF0ZVRleHRWTm9kZSgi56GuIOWumiIpOwoKZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihfY3R4LCBfY2FjaGUsICRwcm9wcywgJHNldHVwLCAkZGF0YSwgJG9wdGlvbnMpIHsKICB2YXIgX2NvbXBvbmVudF9lbF9pbnB1dCA9IF9yZXNvbHZlQ29tcG9uZW50KCJlbC1pbnB1dCIpOwoKICB2YXIgX2NvbXBvbmVudF9lbF9mb3JtX2l0ZW0gPSBfcmVzb2x2ZUNvbXBvbmVudCgiZWwtZm9ybS1pdGVtIik7CgogIHZhciBfY29tcG9uZW50X2VsX29wdGlvbiA9IF9yZXNvbHZlQ29tcG9uZW50KCJlbC1vcHRpb24iKTsKCiAgdmFyIF9jb21wb25lbnRfZWxfc2VsZWN0ID0gX3Jlc29sdmVDb21wb25lbnQoImVsLXNlbGVjdCIpOwoKICB2YXIgX2NvbXBvbmVudF9lbF9mb3JtID0gX3Jlc29sdmVDb21wb25lbnQoImVsLWZvcm0iKTsKCiAgdmFyIF9jb21wb25lbnRfZWxfYnV0dG9uID0gX3Jlc29sdmVDb21wb25lbnQoImVsLWJ1dHRvbiIpOwoKICB2YXIgX2NvbXBvbmVudF9lbF9kaWFsb2cgPSBfcmVzb2x2ZUNvbXBvbmVudCgiZWwtZGlhbG9nIik7CgogIHJldHVybiBfb3BlbkJsb2NrKCksIF9jcmVhdGVCbG9jaygiZGl2IiwgX2hvaXN0ZWRfMSwgW19jcmVhdGVWTm9kZSgiZGl2IiwgX2hvaXN0ZWRfMiwgW19jcmVhdGVWTm9kZShfY29tcG9uZW50X2VsX2RpYWxvZywgewogICAgdGl0bGU6ICLkv6Hmga/lrozlloQiLAogICAgbW9kZWxWYWx1ZTogJGRhdGEuYWRkRm9ybVZpc2libGUsCiAgICAib25VcGRhdGU6bW9kZWxWYWx1ZSI6IF9jYWNoZVs0XSB8fCAoX2NhY2hlWzRdID0gZnVuY3Rpb24gKCRldmVudCkgewogICAgICByZXR1cm4gJGRhdGEuYWRkRm9ybVZpc2libGUgPSAkZXZlbnQ7CiAgICB9KSwKICAgICJiZWZvcmUtY2xvc2UiOiAkb3B0aW9ucy5oYW5kbGVDbG9zZSwKICAgICJhcHBlbmQtdG8tYm9keSI6IHRydWUKICB9LCB7CiAgICBmb290ZXI6IF93aXRoQ3R4KGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIFtfY3JlYXRlVk5vZGUoInNwYW4iLCBfaG9pc3RlZF8zLCBbX2NyZWF0ZVZOb2RlKF9jb21wb25lbnRfZWxfYnV0dG9uLCB7CiAgICAgICAgb25DbGljazogJG9wdGlvbnMuYWRkQ2FuY2VsCiAgICAgIH0sIHsKICAgICAgICBkZWZhdWx0OiBfd2l0aEN0eChmdW5jdGlvbiAoKSB7CiAgICAgICAgICByZXR1cm4gW19ob2lzdGVkXzRdOwogICAgICAgIH0pLAogICAgICAgIF86IDEKICAgICAgICAvKiBTVEFCTEUgKi8KCiAgICAgIH0sIDgKICAgICAgLyogUFJPUFMgKi8KICAgICAgLCBbIm9uQ2xpY2siXSksIF9jcmVhdGVWTm9kZShfY29tcG9uZW50X2VsX2J1dHRvbiwgewogICAgICAgIHR5cGU6ICJwcmltYXJ5IiwKICAgICAgICBvbkNsaWNrOiAkb3B0aW9ucy5hZGRDb25maXJtCiAgICAgIH0sIHsKICAgICAgICBkZWZhdWx0OiBfd2l0aEN0eChmdW5jdGlvbiAoKSB7CiAgICAgICAgICByZXR1cm4gW19ob2lzdGVkXzVdOwogICAgICAgIH0pLAogICAgICAgIF86IDEKICAgICAgICAvKiBTVEFCTEUgKi8KCiAgICAgIH0sIDgKICAgICAgLyogUFJPUFMgKi8KICAgICAgLCBbIm9uQ2xpY2siXSldKV07CiAgICB9KSwKICAgIGRlZmF1bHQ6IF93aXRoQ3R4KGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIFtfY3JlYXRlVk5vZGUoX2NvbXBvbmVudF9lbF9mb3JtLCB7CiAgICAgICAgbW9kZWw6ICRkYXRhLmZvcm0sCiAgICAgICAgcnVsZXM6ICRkYXRhLnJ1bGVzLAogICAgICAgIHJlZjogInJ1bGVGb3JtIiwKICAgICAgICAibGFiZWwtd2lkdGgiOiAkZGF0YS5mb3JtTGFiZWxXaWR0aCwKICAgICAgICBjbGFzczogImRlbW8tcnVsZUZvcm0iCiAgICAgIH0sIHsKICAgICAgICBkZWZhdWx0OiBfd2l0aEN0eChmdW5jdGlvbiAoKSB7CiAgICAgICAgICByZXR1cm4gW19jcmVhdGVDb21tZW50Vk5vZGUoIiBjbGFzcz1cImRlbW8tcnVsZUZvcm1cIuaEj+S5ieS9leWcqO+8nyIpLCBfY3JlYXRlVk5vZGUoX2NvbXBvbmVudF9lbF9mb3JtX2l0ZW0sIHsKICAgICAgICAgICAgbGFiZWw6ICLlkI3np7AiLAogICAgICAgICAgICBwcm9wOiAibmFtZSIsCiAgICAgICAgICAgIHJlcXVpcmVkOiAiIgogICAgICAgICAgfSwgewogICAgICAgICAgICBkZWZhdWx0OiBfd2l0aEN0eChmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFtfY3JlYXRlVk5vZGUoX2NvbXBvbmVudF9lbF9pbnB1dCwgewogICAgICAgICAgICAgICAgbW9kZWxWYWx1ZTogJGRhdGEuZm9ybS5uYW1lLAogICAgICAgICAgICAgICAgIm9uVXBkYXRlOm1vZGVsVmFsdWUiOiBfY2FjaGVbMV0gfHwgKF9jYWNoZVsxXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuICRkYXRhLmZvcm0ubmFtZSA9ICRldmVudDsKICAgICAgICAgICAgICAgIH0pLAogICAgICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiAib2ZmIiwKICAgICAgICAgICAgICAgIHN0eWxlOiB7CiAgICAgICAgICAgICAgICAgICJ3aWR0aCI6ICI5MCUiCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfSwgbnVsbCwgOAogICAgICAgICAgICAgIC8qIFBST1BTICovCiAgICAgICAgICAgICAgLCBbIm1vZGVsVmFsdWUiXSldOwogICAgICAgICAgICB9KSwKICAgICAgICAgICAgXzogMQogICAgICAgICAgICAvKiBTVEFCTEUgKi8KCiAgICAgICAgICB9KSwgX2NyZWF0ZVZOb2RlKF9jb21wb25lbnRfZWxfZm9ybV9pdGVtLCB7CiAgICAgICAgICAgIGxhYmVsOiAi57G75Z6LIiwKICAgICAgICAgICAgcHJvcDogInR5cGUiCiAgICAgICAgICB9LCB7CiAgICAgICAgICAgIGRlZmF1bHQ6IF93aXRoQ3R4KGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICByZXR1cm4gW19jcmVhdGVWTm9kZShfY29tcG9uZW50X2VsX3NlbGVjdCwgewogICAgICAgICAgICAgICAgbW9kZWxWYWx1ZTogJGRhdGEuZm9ybS50eXBlLAogICAgICAgICAgICAgICAgIm9uVXBkYXRlOm1vZGVsVmFsdWUiOiBfY2FjaGVbMl0gfHwgKF9jYWNoZVsyXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuICRkYXRhLmZvcm0udHlwZSA9ICRldmVudDsKICAgICAgICAgICAgICAgIH0pLAogICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICLor7fpgInmi6nnsbvlnosiLAogICAgICAgICAgICAgICAgc3R5bGU6IHsKICAgICAgICAgICAgICAgICAgIndpZHRoIjogIjkwJSIKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9LCB7CiAgICAgICAgICAgICAgICBkZWZhdWx0OiBfd2l0aEN0eChmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBbKF9vcGVuQmxvY2sodHJ1ZSksIF9jcmVhdGVCbG9jayhfRnJhZ21lbnQsIG51bGwsIF9yZW5kZXJMaXN0KCRkYXRhLmdpdmVuVHlwZSwgZnVuY3Rpb24gKGl0ZW0pIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gX29wZW5CbG9jaygpLCBfY3JlYXRlQmxvY2soX2NvbXBvbmVudF9lbF9vcHRpb24sIHsKICAgICAgICAgICAgICAgICAgICAgIGtleTogaXRlbS52YWx1ZSwKICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBpdGVtLmxhYmVsLAogICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW0udmFsdWUKICAgICAgICAgICAgICAgICAgICB9LCBudWxsLCA4CiAgICAgICAgICAgICAgICAgICAgLyogUFJPUFMgKi8KICAgICAgICAgICAgICAgICAgICAsIFsibGFiZWwiLCAidmFsdWUiXSk7CiAgICAgICAgICAgICAgICAgIH0pLCAxMjgKICAgICAgICAgICAgICAgICAgLyogS0VZRURfRlJBR01FTlQgKi8KICAgICAgICAgICAgICAgICAgKSldOwogICAgICAgICAgICAgICAgfSksCiAgICAgICAgICAgICAgICBfOiAxCiAgICAgICAgICAgICAgICAvKiBTVEFCTEUgKi8KCiAgICAgICAgICAgICAgfSwgOAogICAgICAgICAgICAgIC8qIFBST1BTICovCiAgICAgICAgICAgICAgLCBbIm1vZGVsVmFsdWUiXSldOwogICAgICAgICAgICB9KSwKICAgICAgICAgICAgXzogMQogICAgICAgICAgICAvKiBTVEFCTEUgKi8KCiAgICAgICAgICB9KSwgJGRhdGEubm9kZTBFZGdlMSA9PT0gMCA/IChfb3BlbkJsb2NrKCksIF9jcmVhdGVCbG9jayhfY29tcG9uZW50X2VsX2Zvcm1faXRlbSwgewogICAgICAgICAgICBrZXk6IDAsCiAgICAgICAgICAgIGxhYmVsOiAi5bGe5oCnIiwKICAgICAgICAgICAgcHJvcDogInByb3BlcnR5IgogICAgICAgICAgfSwgewogICAgICAgICAgICBkZWZhdWx0OiBfd2l0aEN0eChmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFtfY3JlYXRlVk5vZGUoX2NvbXBvbmVudF9lbF9zZWxlY3QsIHsKICAgICAgICAgICAgICAgIG1vZGVsVmFsdWU6ICRkYXRhLmZvcm0ucHJvcGVydHksCiAgICAgICAgICAgICAgICAib25VcGRhdGU6bW9kZWxWYWx1ZSI6IF9jYWNoZVszXSB8fCAoX2NhY2hlWzNdID0gZnVuY3Rpb24gKCRldmVudCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gJGRhdGEuZm9ybS5wcm9wZXJ0eSA9ICRldmVudDsKICAgICAgICAgICAgICAgIH0pLAogICAgICAgICAgICAgICAgc3R5bGU6IHsKICAgICAgICAgICAgICAgICAgIndpZHRoIjogIjkwJSIKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICBtdWx0aXBsZTogIiIsCiAgICAgICAgICAgICAgICBmaWx0ZXJhYmxlOiAiIiwKICAgICAgICAgICAgICAgICJhbGxvdy1jcmVhdGUiOiAiIiwKICAgICAgICAgICAgICAgICJkZWZhdWx0LWZpcnN0LW9wdGlvbiI6ICIiLAogICAgICAgICAgICAgICAgIm5vLWRhdGEtdGV4dCI6ICLovpPlhaXlt7LlrZjlnKjnmoTlsZ7mgKfkvJrlj5bmtojli77pgInlk6YiLAogICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICLlnKjov5nph4zlj6/ku6XovpPlhaXlsZ7mgKflk6YiCiAgICAgICAgICAgICAgfSwgbnVsbCwgOAogICAgICAgICAgICAgIC8qIFBST1BTICovCiAgICAgICAgICAgICAgLCBbIm1vZGVsVmFsdWUiXSldOwogICAgICAgICAgICB9KSwKICAgICAgICAgICAgXzogMQogICAgICAgICAgICAvKiBTVEFCTEUgKi8KCiAgICAgICAgICB9KSkgOiBfY3JlYXRlQ29tbWVudFZOb2RlKCJ2LWlmIiwgdHJ1ZSldOwogICAgICAgIH0pLAogICAgICAgIF86IDEKICAgICAgICAvKiBTVEFCTEUgKi8KCiAgICAgIH0sIDgKICAgICAgLyogUFJPUFMgKi8KICAgICAgLCBbIm1vZGVsIiwgInJ1bGVzIiwgImxhYmVsLXdpZHRoIl0pXTsKICAgIH0pLAogICAgXzogMQogICAgLyogU1RBQkxFICovCgogIH0sIDgKICAvKiBQUk9QUyAqLwogICwgWyJtb2RlbFZhbHVlIiwgImJlZm9yZS1jbG9zZSJdKV0pXSk7Cn0="},{"version":3,"sources":["C:\\Users\\Zhaoning\\Desktop\\HCI\\src\\components\\CytoscapeKG.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n    <div class='knowledge-graph-cy'>\n        <div id=\"graph\">\n          <el-dialog title=\"信息完善\" v-model=\"addFormVisible\" :before-close=\"handleClose\" :append-to-body=\"true\"><!--:append-to-body保证了弹窗时周围背景不能触发事件-->\n                <el-form :model=\"form\" :rules=\"rules\" ref=\"ruleForm\" :label-width=\"formLabelWidth\" class=\"demo-ruleForm\"><!-- class=\"demo-ruleForm\"意义何在？-->\n                    <el-form-item label=\"名称\" prop=\"name\" required>\n                        <el-input v-model=\"form.name\" autocomplete=\"off\" style=\"width:90%\"></el-input>\n                    </el-form-item>\n                    <el-form-item label=\"类型\" prop=\"type\">\n                        <el-select v-model=\"form.type\" placeholder=\"请选择类型\" style=\"width:90%\">\n                            <el-option v-for=\"item in givenType\" :key=\"item.value\" :label=\"item.label\" :value=\"item.value\"></el-option>\n                        </el-select>\n                    </el-form-item>\n                    <el-form-item label=\"属性\" prop=\"property\" v-if=\"node0Edge1===0\">\n                        <el-select\n                                v-model=\"form.property\"\n                                style=\"width:90%\"\n                                multiple\n                                filterable\n                                allow-create\n                                default-first-option\n                                no-data-text=\"输入已存在的属性会取消勾选哦\"\n                                placeholder=\"在这里可以输入属性哦\">\n                        </el-select>\n                    </el-form-item>\n\n                </el-form>\n                <template #footer>\n                    <span class=\"dialog-footer\">\n                        <el-button @click=\"addCancel\">取 消</el-button>\n                        <el-button type=\"primary\" @click=\"addConfirm\">确 定</el-button>\n                    </span>\n                </template>\n            </el-dialog>\n        </div>\n\n    </div>\n</template>\n\n<script>\n    //注意！！！\n    //所有对property的处理都标注了注释：property处理\n\n    //日后修改：\n    //颜色改变增加调色板选项\n    //颜色的存储可以放在data（大小同理），读取时在渲染函数中访问data中相应字段来渲染，但是在其他样式与颜色解耦之前无意义（例：会把选中状态之类的颜色存进去）\n    //边的添加和修改增加source和target的可修改功能\n    //eles.hasClass()和.addClass()帮助edge把class属性的添加移动到rendEdge里\n    //ele.isNode()帮助add等方法优化group==='nodes'的逻辑\n    //node0Edge1这个属性换成字符串\n    // 宽高修改逻辑暂时在EditBar，考虑这个样式的职责要不要放在本KG组件的updataAllNodeFontSize（到时候再改个方法名表示同时修改节点大小和字体大小）\n    //考虑引入https://github.com/kaluginserg/cytoscape-node-html-label\n    //cola布局挺好的感觉，有空加一下\n    import axios from 'axios'\n    import $ from 'jquery'\n    import cytoscape from 'cytoscape'\n    import { mapState,mapMutations,mapGetters } from 'vuex';\n\n    import d3Force from 'cytoscape-d3-force';\n    cytoscape.use( d3Force );\n\n    import contextMenus from 'cytoscape-context-menus';\n    cytoscape.use(contextMenus);\n\n    import popper from 'cytoscape-popper';\n    cytoscape.use( popper );\n    import tippy,{sticky} from 'tippy.js';\n    import 'tippy.js/dist/tippy.css';\n\n    window.jQuery = window.$ = $\n\n    export default {\n        name: 'CytoscapeKG',\n        data() {\n              let nameCheck = (rule,value,callback) => {\n                  console.log('nameCheck');\n                  let validName = value.trim();\n                  if(this.form.nameNow&&this.form.nameNow===validName){\n                      return callback();\n                  }\n                  let nameValid = /\\S/;\n                  if(!nameValid.test(validName)){//可添加正则表达式等逻辑\n                      return callback(new Error('名称不能为空哟'));\n                  }\n                  if(this.node0Edge1===0){\n                      if(this.isUnique(this.cy.nodes(),val=>val.data(\"name\"),validName)){\n                          callback();\n                      }else {\n                          callback(new Error('该实体已存在哦，换一个名字吧，亲~'));\n                      }\n                  }else{\n                      let {source,target} = this.form.edgeCondition;\n                      let dupEdges = this.cy.edges().filter(val=>val.data(\"source\")===source).filter(val=>val.data(\"target\")===target);\n                      if(dupEdges.length===0||this.isUnique(dupEdges,val=>val.data(\"relation\"),validName)){\n                          callback();\n                      }else{\n                          callback(new Error('该关系已存在哦，换一个名字吧，亲~'));\n                      }\n                  }\n\n            };\n            //property处理\n            // let propLenCheck = (rule,value,callback) => {\n            //     console.log('propLenCheck');\n            //     let len = 0;\n            //     const limit = 255;\n            //     let invalid = false;\n            //     let errorReg = /\\s/;\n            //     for(let i = 0;i < value.length;i++){\n            //         if(errorReg.test(value[i])){\n            //             invalid = true;\n            //             break;\n            //         }\n            //         len += value[i]+1;\n            //     }\n            //     len-=1;\n            //     if(invalid){\n            //         callback(new Error(\"属性中不能含有空哟~\"));\n            //     }else if(len>limit){\n            //         callback(new Error(\"属性值数据量太大啦，麻烦去掉长度过长的属性哟~\"));\n            //     }else{\n            //         callback();\n            //     }\n            // };\n            return {\n                node0Edge1: 0,\n                // editMode: false,\n                addFormVisible : false,\n                givenType: [],\n                form: {\n                    name: '',\n                    type: '',\n                    property: [],\n                    edgeCondition:{source:'',target:''},\n                    //以下为借用form的reset来自动清空的属性\n                    nameNow: '',\n                    formCallback: ()=>{console.log(\"this.form.formCallback被意外调用\")}\n                },//此处的值会作为初始值存在，在this.$refs['ruleForm'].resetFields()后会恢复成初始值\n                rules:{\n                    name:[\n                        {validator:nameCheck, trigger:'blur'}\n                    ],\n                    type:[//如果设置了初始值，这里就不会被用到\n                        {required:true,message:'请选择类型',trigger:'change'}\n                    ],\n                    //property处理\n                    // property:[\n                    //     {validator:propLenCheck,trigger:'change'}\n                    // ]\n                },\n                formLabelWidth: '12%'\n                // 自定义校验 callback 必须被调用。 更多高级用法可参考 async-validator\n                // https://github.com/yiminghe/async-validator\n            };\n        },\n\n        computed: {\n            ...mapState({\n                defaultStyle: state => state.workspace.defaultStyle,\n                shapeType: state => state.workspace.shapeType,\n                lineStyleType: state => state.workspace.lineStyleType,\n                nodeType: state => state.workspace.nodeType,\n                edgeType: state => state.workspace.edgeType,\n                cy: state => state.workspace.cy,\n                nodeRadius: state => state.workspace.nodeRadius,\n                nodeFontSize: state => state.workspace.nodeFontSize,\n                json_src_path: state => state.workspace.json_src_path,\n                project: state => state.project,\n            }),\n        },\n        watch: {\n            json_src_path(now, old){\n                this.getData(now);\n            },\n            project(now, old){\n              let data = {\n                edges: JSON.parse(JSON.stringify(this.project.edges)),\n                nodes: JSON.parse(JSON.stringify(this.project.nodes)),\n              };\n              this.dataHandle(data);\n            },\n            nodeFontSize(now,old){//监听节点大小变化，如果刚变为未设定就需要修改节点字体大小\n                console.log(\"nodeFontSize watched\")\n                if(this.nodeFontSize===''){\n                    this.updateAllNodeFontSize();\n                }\n            },\n            nodeRadius(now,old){//监听节点大小来改变文字大小，但是字体大小如果处于被设定状态就不能改\n                console.log(\"nodeRadius watched\")\n                if(this.nodeFontSize===''){\n                    this.updateAllNodeFontSize();\n                }\n            }\n        },\n        mounted () {\n            //禁用右键菜单（应该防止浏览器菜单行为干扰cy的菜单行为）\n            // document.oncontextmenu = () => {\n            //     event.returnValue = false;\n            // }\n            if (this.project !== undefined && this.project !== null){\n              let data = {\n                edges: this.project.edges,\n                nodes: this.project.nodes,\n              };\n              this.dataHandle(data);\n            }\n        },\n        methods: {\n            ...mapMutations(['setCy','setElements','trigger_statistic_data_change', 'setProject']),\n\n            //读数据，然后交给dataHandle\n            getData(url) {\n                axios.get(url)\n                    .then(res => {\n                        this.dataHandle(res.data);\n                        this.setProject(res.data);\n                    })\n                    .catch(err => {\n                        console.error(err);\n                        this.$message.error('文件数据格式不正确');\n                    })\n            },\n\n            //在data中存数据，并进行数据展示的预处理\n            dataHandle(data) {\n                // this.data = JSON.parse(JSON.stringify(data))\n                data.edges.forEach((val) => {\n                    val.classes = 'autorotate';\n                    val.data.type = val.data.type || 'default';\n                })\n                let default_color = \"#9c8f96\";//和add-node方法中初始化颜色耦合，必须同时修改\n                data.nodes.forEach((val) => {\n                    val.data.type = val.data.type || 'default';\n                    val.data.color = val.data.color || default_color;//将颜色绑定在数据里，在workspace中修改为background-color:data(color),实现颜色持久化\n                    val.data.typeset = val.data.typeset || {x: -1, y: -1, parent: ''};\n                })\n                let that = this;\n                const loading = this.$loading({\n                  lock: true,\n                  text: '...加载中...',\n                  spinner: 'el-icon-loading',\n                  background: 'rgba(255, 255,255, 0.8)'\n                });\n                try{\n                    this.graph(that, data);\n                }finally{\n                    this.$nextTick(() => {\n                      loading.close();\n                    });\n                }\n\n            },\n\n            //让过长的内容作为展示的标题时省略\n            fontShow(text) {\n                if (text && text.length > 5) {\n                    return text.substring(0, 3) + \"...\"\n                }\n                return text\n            },\n\n            //根据内容设置字体大小，使之不会超出节点（未验证）\n            //最好改成根据实体大小设置字体大小\n            fontStyle(length,width) {\n                if(this.nodeFontSize!==''){\n                    return {\n                        \"font-size\": this.nodeFontSize + \"px\"\n                    };\n                }\n                let defaultWidth = 30;\n                let minWidth = 12;\n                let fontSize = defaultWidth - (length - 2) * 6;//这个计算字体大小的算式可能有点拉胯，\n                //根据节点大小调整文字大小\n                let nodeWidth = width?width:defaultWidth;\n                fontSize = fontSize*nodeWidth/defaultWidth;\n                if (!fontSize || fontSize < minWidth) {//\"!fontSize\"有效吗，不懂诶\n                    fontSize = minWidth;\n                }\n                return {\n                    \"font-size\": fontSize + \"px\"\n                };\n            },\n\n            //帮助node合适地展示text\n            rendNode(target, that) {\n                let data = target.data();\n                const text = that.fontShow(data.name)\n\n                //如果没有设定大小，就按照节点本身大小（节点大小不是时刻是设定大小吗？按现在的写法，我觉得新增的节点没有初始化到渲染到设定大小）\n                let widthNow = this.nodeRadius===''?this.getNodeWidth(target):this.nodeRadius;\n\n                widthNow = parseInt(widthNow+'');//确保是数字类型\n                //获取节点宽度的数字值来调节字体大小\n                let style = that.fontStyle(text.length,widthNow);\n\n                style.shape = this.shapeType[data.type];\n                style.label = text;\n                if(this.nodeRadius!==''){//和EditBar中nodeRadius监听方法逻辑耦合，必须同时修改\n                    style.width = widthNow+'px';\n                    style.height = widthNow+'px';\n                }\n                target.style(style);\n            },\n\n            getNodeWidth(target){//返回值为数字类型\n                let widthProp = target.style(\"width\");\n                let defaultWidth = 30;\n                if(widthProp){\n                    return parseInt(widthProp.match(/(\\S*)px/)[1]);//随便搜的，不知道有没有更好写法\n                }else{\n                    return defaultWidth;\n                }\n            },\n\n            updateAllNodeFontSize(){\n                //宽高修改逻辑暂时在EditBar，感觉这个样式的职责应该放在KG组件\n                //由于宽高修改在EditBar，此处默认NodeRadius如果已设定那就已经更新到全部节点了，例外情况已在rendNode中考虑\n                //此处为了防止多做操作就没有调用rendNode，结果是逻辑一部分和rendNode重复，形成重复耦合\n                let that = this;\n                let cy = that.cy;\n                that.batch(cy,()=>{\n                    cy.nodes().forEach(val => {\n                        let widthNow = that.getNodeWidth(val);//默认NodeRadius如果被设置则节点属性已经更新到和它一样\n                        let nameShown = val.style(\"label\");\n                        let style = that.fontStyle(nameShown.length,widthNow);\n                        val.style(style);\n                    });\n                });\n            },\n\n            rendEdge(target,that){\n                let data = target.data();\n                const text = that.fontShow(data.relation);\n                target.style({label:text,'line-style':this.lineStyleType[data.type]});\n                // const style = that.fontStyle(text.length);\n                // target.style(style);\n                // target.addClass('autorotate');\n            },\n\n            //作图有关的设置\n            graph(that, data) {\n                let bfLayout = {\n                    name: 'breadthfirst',\n                        minDist: 40,\n                        fit: true,\n                        padding: 30,\n                        boundingBox: undefined,\n                        animate: false,\n                        animationDuration: 500,\n                        animationEasing: undefined,\n                        animateFilter: function (node, i) {\n                        return true;\n                    },\n                    ready: undefined,\n                        stop: undefined,\n                        transform: (node, position) => {\n                        return position\n                    }\n                };\n                let presetLayout = {\n                    name: 'preset',\n\n                    positions: undefined, // map of (node id) => (position obj); or function(node){ return somPos; }\n                    zoom: undefined, // the zoom level to set (prob want fit = false if set)\n                    pan: undefined, // the pan level to set (prob want fit = false if set)\n                    fit: true, // whether to fit to viewport\n                    padding: 30, // padding on fit\n                    animate: false, // whether to transition the node positions\n                    animationDuration: 500, // duration of animation in ms if enabled\n                    animationEasing: undefined, // easing of animation if enabled\n                    animateFilter: function ( node, i ){ return true; }, // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n                    ready: undefined, // callback on layoutready\n                    stop: undefined, // callback on layoutstop\n                    transform: function (node, position ){ return position; } // transform a given node position. Useful for changing flow direction in discrete layouts\n                };\n                let cy = cytoscape({\n                    container: $('#graph'),\n                    boxSelectionEnabled: false,\n                    autounselectify: false,\n                    style: this.defaultStyle,\n                    elements: data,\n                    hideLabelsOnViewPort: false,\n                    minZoom: 0.15,\n                    maxZoom: 8,\n                    wheelSensitivity: 0.1,   //warning\n                    layout: presetLayout\n                });\n                this.setCy(cy);\n                //为了恢复打开时的布局而存的elements，目前用到的只有elements中nodes的id和position映射关系\n                //虽然完全可以只存这个map<id,position>，但为了可扩展性考虑暂时先存elements(扩展时可能也用不到hhh)\n                let elements = JSON.parse(JSON.stringify(this.cy.json().elements));//存入运行时的cy，确保都有id\n                this.setElements(elements);\n\n                this.batch(cy,()=>{\n                    cy.nodes().forEach(val => {\n                        that.rendNode(val, that);\n                    });\n\n                    cy.edges().forEach(val => {\n                        that.rendEdge(val, that);\n                    });\n                });\n\n\n                cy.on('mouseover', 'node', event => {\n                    let target = event.target || event.cyTarget;\n                    // console.log(\"mouseover node: \",target);\n                    let data = target.data();\n                    const minSize = 48;//看起来可以的试验值，无特殊意义\n                    let fontSize = parseInt(target.style(\"font-size\").match(/(\\S*)px/)[1])*1.2;\n                    fontSize = fontSize<minSize?minSize:fontSize;\n                    target.style({label:data.name,fontSize: fontSize,'z-index':9999});\n                    if(!target.scratch('tip')){\n                        let text = \"类型: \"+data.type+'<br/>'+\"属性: \" +'<br/>' + this.property2String(data.property)\n                        target.scratch('tip',that.makeTippy(target,text));\n                    }\n                    target.scratch('tip').show();\n                })\n                    .on('mouseout', 'node', event => {\n                        let target = event.target || event.cyTarget;\n                        that.rendNode(target, that);\n                        if(target.scratch('tip')){\n                            target.scratch('tip').destroy();\n                            target.removeScratch('tip');\n                            // console.log(target.scratch());\n                        }\n                        target.style({'z-index':0});\n                    })\n                    //edge不能改变边的颜色，否则和选中机制冲突（那处也会改变颜色）\n                    .on('mouseover', 'edge', event => {\n                        let target = event.target || event.cyTarget;\n                        // console.log(\"mouseover edge: \",target);\n                        let data = target.data();\n                        //如果要改旋转，是\"edge-text-rotation\": \"none\"和\"edge-text-rotation\": \"autorotate\"\n                        target.style({label:data.relation,fontSize: 36, width: 6, color: '#bc5f6a','z-index':9999});//此数无意义，仅仅需要比rendNode最大label的36更大即可\n                        if(!target.scratch('tip')){\n                            let text = \"类型: \"+data.type;\n                            target.scratch('tip',that.makeTippy(target,text));\n                        }\n                        target.scratch('tip').show();\n                    })\n                    .on('mouseout', 'edge', event => {\n                        let target = event.target || event.cyTarget;\n                        that.rendEdge(target,that);\n                        target.style({fontSize: 24, width: 3, color: '#e3a6a1','z-index':0});//与上文edge的初始配置保持一致\n                        if(target.scratch('tip')){\n                            target.scratch('tip').destroy();\n                            target.removeScratch('tip');\n                            // console.log(target.scratch());\n                        }\n                    })\n\n                // 绑定右键单击的事件\n                const barHandler = event => {\n                    if (allSelected('node')) {\n                        contextMenu.hideMenuItem('select-all-nodes');\n                        contextMenu.showMenuItem('unselect-all-nodes');\n                    } else {\n                        contextMenu.hideMenuItem('unselect-all-nodes');\n                        contextMenu.showMenuItem('select-all-nodes');\n                    }\n                    if (allSelected('edge')) {\n                        contextMenu.hideMenuItem('select-all-edges');\n                        contextMenu.showMenuItem('unselect-all-edges');\n                    } else {\n                        contextMenu.hideMenuItem('unselect-all-edges');\n                        contextMenu.showMenuItem('select-all-edges');\n                    }\n\n                };\n                cy.on('cxttap', barHandler);  //cxttap为右键单击\n\n                const allSelected = function (type) {\n                    if (type === 'node') {\n                        return cy.nodes().length === cy.nodes(':selected').length;\n                    } else if (type === 'edge') {\n                        return cy.edges().length === cy.edges(':selected').length;\n                    }\n                    return false;\n                };\n                const selectAllOfTheSameType = function (type) {\n                    if (type === 'node') {\n                        cy.nodes().select();\n                    } else if (type === 'edge') {\n                        cy.edges().select();\n                    }\n                };\n                const unselectAllOfTheSameType = function (type) {\n                    if (type === 'node') {\n                        cy.nodes().unselect();\n                    } else if (type === 'edge') {\n                        cy.edges().unselect();\n                    }\n                };\n\n\n                let removed = [];  //为了撤销删除而使用的缓存，以后可以改成恢复多次\n\n                let contextMenu = cy.contextMenus({\n                    menuItems: [\n                        {\n                            id: 'edit',\n                            content: '编辑',\n                            selector: 'node, edge',\n                            hasTrailingDivider: false,\n                            onClickFunction: function (event) {\n                                let target = event.target || event.cyTarget;\n                                const group = target.group()\n                                const data = target.data()\n\n                                const name = group === 'nodes' ? 'name' : 'relation'\n                                if(group==='nodes'){//property处理\n                                    that.node0Edge1 = 0;\n                                    that.givenType = that.nodeType;\n                                    that.form.property = that.propertyToArray(data.property);\n                                }else{\n                                    that.node0Edge1 = 1;\n                                    that.givenType = that.edgeType;\n                                }\n                                that.form.nameNow = that.form.name = data[name];\n                                that.form.type = data.type;\n                                that.addFormVisible = true;\n                                that.form.formCallback = addForm => {\n                                    console.log(\"before edit: target\", target);\n                                    let obj = {\n                                        [name]: addForm.name,\n                                        type: addForm.type,\n                                    };\n                                    if(group==='nodes'){//property处理\n                                        obj.property = that.arrayToProperty(addForm.property);\n                                    }\n                                    target.data(obj);\n                                    let conflict = false;\n                                    if (group==='nodes') {\n                                        that.rendNode(target, that);\n                                        for(let i=0;i<removed.length;i++){\n                                            let val = removed[i];\n                                            if(val.group()==='nodes'&&val.data(name)===addForm.name){\n                                                conflict = true;\n                                                break;\n                                            }\n                                        }\n                                    }else{\n                                        that.rendEdge(target,that);\n                                        for(let i=0;i<removed.length;i++){\n                                            let val = removed[i];\n                                            let valData = val.data();\n                                            if(val.group()==='edges'\n                                                &&valData.source===data.source\n                                                &&valData.target===data.target\n                                                &&valData[name]===addForm.name){\n                                                conflict = true;\n                                                break;\n                                            }\n                                        }\n                                    }\n                                    if(conflict){\n                                        console.log(\"conflict in removed, delete it all\");\n                                        contextMenu.hideMenuItem('undo-last-remove');\n                                        removed = [];\n                                    }\n                                    console.log(\"after edit: target\", target);\n                                };\n                            }\n                        },\n                        {\n                          id: 'color',\n                          content: '颜色',\n                          selector: 'node',\n                          hasTrailingDivider: true,\n                          submenu: [\n                            {\n                              id: 'color-red',\n                              content: '红',\n                              onClickFunction: function (event) {\n                                let target = event.target || event.cyTarget;\n                                target.data('color', '#e89d96');//颜色持久化\n                              },\n                            },\n                            {\n                              id: 'color-yellow',\n                              content: '黄',\n                              onClickFunction: function (event) {\n                                let target = event.target || event.cyTarget;\n                                target.data('color', '#ebc57c');//颜色持久化\n                              },\n                            },\n                            {\n                              id: 'color-light-blue',\n                              content: '浅蓝',\n                              onClickFunction: function (event) {\n                                let target = event.target || event.cyTarget;\n                                target.data('color', 'lightblue');//颜色持久化\n                              },\n                            },\n                            {\n                                id: 'color-blue-slate',\n                                content: '靛青',\n                                onClickFunction: function (event) {\n                                  let target = event.target || event.cyTarget;\n                                  target.data('color', '#6a85ce');//颜色持久化\n                                }\n                            },\n                            {\n                              id: 'color-brown',\n                              content: '棕',\n                              onClickFunction: function (event) {\n                                let target = event.target || event.cyTarget;\n                                target.data('color', '#9c8f96');//颜色持久化\n                              },\n                            },\n                          ]\n                        },\n                        {\n                            id: 'undo-last-remove',\n                            content: '撤销最近一次删除',\n                            selector: 'node, edge',\n                            show: false,\n                            coreAsWell: true,\n                            onClickFunction: function (event) {\n                                if (removed) {\n                                    console.log(\"before undoing remove: nodeCount\", cy.nodes().length);\n                                    console.log(\"before undoing remove: edgeCount\", cy.edges().length);\n                                    removed.restore();\n                                    removed = [];\n                                    console.log(\"after undoing remove: nodeCount\", cy.nodes().length);\n                                    console.log(\"after undoing remove: edgeCount\", cy.edges().length);\n                                }\n\n                                that.trigger_statistic_data_change();\n                                contextMenu.hideMenuItem('undo-last-remove');\n                            }\n                        },\n                        {\n                            id: 'add-node',\n                            content: '实体',\n                            image: {src: \"/icons/add.svg\", x: 7, y: 8}, // menu icon\n                            coreAsWell: true,\n                            hasTrailingDivider: true,\n                            onClickFunction: function (event) {\n                                that.node0Edge1 = 0;\n                                that.givenType = that.nodeType;\n                                that.addFormVisible = true;\n                                let pos = event.position || event.cyPosition;\n                                let newObj = {\n                                    group: 'nodes',\n                                    position: {\n                                        x: pos.x,\n                                        y: pos.y\n                                    }\n                                };\n                                that.form.formCallback = addForm => {\n                                    let default_color = \"#9c8f96\";\n                                    newObj.data = {\n                                        name:addForm.name,\n                                        type:addForm.type,\n                                        color:default_color,//和初始化时的颜色耦合，必须是相同的default_color\n                                        property:that.arrayToProperty(addForm.property)//property处理\n                                    };\n                                    let collection = cy.add(newObj);\n                                    that.rendNode(collection[0], that);\n                                    that.trigger_statistic_data_change();\n                                };\n                            }\n                        },\n                        {\n                            id: 'add-edge',\n                            content: '关系',\n                            selector: 'node',\n                            image: {src: \"/icons/add.svg\", x: 7, y: 8}, // menu icon\n                            onClickFunction: function (event) {\n                                let starget = event.target || event.cyTarget;\n                                let color_before = starget.style('background-color');\n                                // starget.style({\n                                //     //\"border-width\": 4,\n                                //     //\"border-color\": \"#847072\",\n                                //     \"background-color\": '#dcc1b0',\n                                //     //'text-outline-color': \"#847072\",\n                                //     //'text-outline-width': 4,\n                                // });\n                                starget.data(\"color\",'#dcc1b0');//颜色持久化\n                                let sid = starget.data(\"id\");\n                                cy.once('tap', event => {\n                                    console.log(\"start adding an edge\");\n                                    let ttarget = event.target || event.cyTarget;\n                                    if (ttarget !== cy && ttarget.group() === 'nodes') {\n                                        let tid = ttarget.data(\"id\");\n                                        that.node0Edge1 = 1;\n                                        that.givenType = that.edgeType;\n                                        that.form.edgeCondition = {source:sid,target:tid};\n                                        that.addFormVisible = true;\n                                        let newEdge = {\n                                            group: 'edges',\n                                            classes: 'autorotate'\n                                        };\n                                        that.form.formCallback = addForm => {\n                                            newEdge.data = {\n                                                relation: addForm.name,\n                                                source: addForm.edgeCondition.source,\n                                                target: addForm.edgeCondition.target,\n                                                type: addForm.type\n                                            };\n                                            let collection = cy.add(newEdge);\n                                            that.rendEdge(collection[0], that);\n                                            that.trigger_statistic_data_change();\n                                        };\n                                    }\n                                    starget.data({'color': color_before});//颜色持久化\n                                });\n                            }\n                        },\n                        {\n                            id: 'remove',\n                            content: '删除',\n                            hasTrailingDivider: true,\n                            image: {src: \"/icons/remove.svg\", x: 7, y: 8}, // menu icon\n                            selector: 'node, edge',\n                            onClickFunction: function (event) {\n                                let target = event.target || event.cyTarget;\n                                console.log(\"before remove: nodeCount\", cy.nodes().length);\n                                console.log(\"before remove: edgeCount\", cy.edges().length);\n                                removed = target.remove();\n                                console.log(\"after remove: nodeCount\", cy.nodes().length);\n                                console.log(\"after remove: edgeCount\", cy.edges().length);\n\n                                that.trigger_statistic_data_change();\n                                contextMenu.showMenuItem('undo-last-remove');\n                            }\n                        },\n                        {\n                            id: 'select-all-nodes',\n                            content: '全选实体',\n                            selector: 'node',\n                            coreAsWell: true,\n                            show: true,\n                            onClickFunction: function (event) {\n                                selectAllOfTheSameType('node');\n\n                                contextMenu.hideMenuItem('select-all-nodes');\n                                contextMenu.showMenuItem('unselect-all-nodes');\n                            }\n                        },\n                        {\n                            id: 'unselect-all-nodes',\n                            content: '取消全选实体',\n                            selector: 'node',\n                            coreAsWell: true,\n                            show: false,\n                            onClickFunction: function (event) {\n                                unselectAllOfTheSameType('node');\n\n                                contextMenu.showMenuItem('select-all-nodes');\n                                contextMenu.hideMenuItem('unselect-all-nodes');\n                            }\n                        },\n                        {\n                            id: 'select-all-edges',\n                            content: '全选关系',\n                            selector: 'edge',\n                            coreAsWell: true,\n                            show: true,\n                            onClickFunction: function (event) {\n                                selectAllOfTheSameType('edge');\n\n                                contextMenu.hideMenuItem('select-all-edges');\n                                contextMenu.showMenuItem('unselect-all-edges');\n                            }\n                        },\n                        {\n                            id: 'unselect-all-edges',\n                            content: '取消全选关系',\n                            selector: 'edge',\n                            coreAsWell: true,\n                            show: false,\n                            hasTrailingDivider: true,\n                            onClickFunction: function (event) {\n                                unselectAllOfTheSameType('edge');\n\n                                contextMenu.showMenuItem('select-all-edges');\n                                contextMenu.hideMenuItem('unselect-all-edges');\n                            }\n                        },\n                    ],\n                    // css classes that menu items will have\n                    menuItemClasses: [\n                        // add class names to this list, like: 'custom-menu-item'\n                    ],\n                    // css classes that context menu will have\n                    contextMenuClasses: [],\n                    // Indicates that the menu item has a submenu. If not provided default one will be used\n                    submenuIndicator: {src: '/icons/submenu-indicator-default.svg', width: 12, height: 12}\n                });\n            },\n\n            isUnique(arrays,propFunc,name){\n                for(let i=0;i<arrays.length;i++){\n                    if(propFunc(arrays[i])===name){\n                        return false\n                    }\n                }\n                return true\n            },\n\n            //dialog组件\n            resetForm(){\n                this.$refs['ruleForm'].resetFields();\n                //本来只需要上面这一行\n                //由于上一行的作用是恢复至初始值，而由于编辑和添加dialog共用，如果先使用编辑，则编辑的值成为初始值\n                //为简单解决这一问题，附加一个手动清空form的操作如下\n                this.form = {\n                    name: '',\n                    type: '',\n                    property: [],\n                    edgeCondition:{source:'',target:''},\n                    nameNow: '',\n                    formCallback: ()=>{console.log(\"this.form.formCallback被意外调用\")}\n                };\n            },\n\n            handleClose(done) {\n                let that = this;\n                this.$confirm('所作的编辑将不会保存')\n                    .then(_ => {\n                        done();\n                        that.resetForm();\n                    })\n                    .catch(_ => {});\n            },\n\n            //addForm组件\n            addCancel(){\n                this.addFormVisible = false;\n                this.resetForm();\n\n            },\n            addConfirm(){\n                this.$refs['ruleForm'].validate((valid) => {\n                    if (valid) {\n                        this.addFormVisible = false;\n                        let addForm = JSON.parse(JSON.stringify(this.form));//深拷贝后传参，不破坏原来的值//可能没必要\n                        addForm.name = addForm.name.trim();//名称和校验时一样前后无空格\n                        this.form.formCallback(addForm);\n                        this.resetForm();\n                        // this.trigger_statistic_data_change();//因为在各个callback函数中已经写了，由于背后机制是布尔值取反，所以重复操作会导致无法监听到布尔值变化\n                    } else {\n                        alert('好像哪里有问题，操作失败了呢……');\n                    }\n                });\n            },\n\n            makeTippy(ele, text){//ele需传入cy的ele\n                var ref = ele.popperRef();\n\n                // Since tippy constructor requires DOM element/elements, create a placeholder\n                var dummyDomEle = document.createElement('div');\n\n                var tip = tippy( dummyDomEle, {\n                    getReferenceClientRect: ref.getBoundingClientRect,\n                    trigger: 'manual', // mandatory\n                    // dom element inside the tippy:\n                    content: function(){ // function can be better for performance\n                        var div = document.createElement('div');\n\n                        div.innerHTML = text;\n\n                        return div;\n                    },\n                    // your own preferences:\n                    arrow: true,\n                    placement: 'bottom',\n                    offset: [20, 30],\n                    hideOnClick: false,\n                    // enable it\n                    // sticky: true,\n                    // only check the \"reference\" rect for changes\n                    sticky: 'reference',\n                    // only check the \"popper\" rect for changes\n                    // sticky: 'popper',\n                    plugins: [sticky],\n                    zIndex: 10,//默认9999，修改小些避免遮住弹窗\n\n\n                    // if interactive:\n                    interactive: true,\n                    appendTo: document.body // or append dummyDomEle to document.body\n                } );\n\n                return tip;\n            },\n\n            // **Allow for manipulation of elements without triggering multiple style calculations or multiple redraws.**\n            batch(cy,func){\n                cy.startBatch();\n                func();\n                cy.endBatch();\n            },\n            // A batch should correspond to a single visual operation. Usually a batch should contain calls only to the following functions:\n            // Modifying state: eles.data(), eles.scratch(), eles.addClass(), eles.removeClass(), etc.\n            // Building collections: eles.union(), eles.difference(), eles.intersection(), etc.\n            // Comparison: eles.same(), eles.some(), etc.\n            // Iteration: eles.forEach(), eles.empty(), etc.\n            // Traversal: node.outgoers(), eles.bfs(), etc.\n            // Algorithms: eles.dijkstra(), eles.degreeCentrality(), etc.\n\n            // 把对象转化为字符串\n            property2String(props){\n                let result = '';\n                for(let key in props){\n                    let val = props[key];\n                    if(val instanceof Array){\n                        result += '· ' + key + '-' + val.join(',') + '</br>';\n                    }else{\n                        result += '· ' + key + '-' + val + '</br>';\n                    }\n\n                }\n                return result;\n            },\n\n            propertyToArray(props){\n                let result = [];\n                for(let key in props){\n                    let val = props[key];\n                    if(val instanceof Array){\n                        result.push(key + ':' + val.join(','));\n                    }else{\n                        result.push(key + ':' + val);\n                    }\n\n                }\n                return result;\n            },\n\n            arrayToProperty(array){\n                let result = {};\n                let defaultItem = [];\n                if(!array) return result;\n                for(let item of array){\n                    let index = item.search(/[:：]/);\n                    let key='',content='';\n                    if(index>=0 && index<item.length-1){\n                        key = item.slice(0,index);\n                        content = item.slice(index+1);\n                    } else{\n                        content = item;\n                    }\n\n                    let pauseWord = /[;,.；，。]/;\n                    if(content.search(pauseWord)===-1){\n                        let errorReg = /\\s/;\n                        if(key&&!errorReg.test(key)){\n                            result[key] = content;\n                        }else{\n                            defaultItem.push(item);\n                        }\n                    }else{\n                        content = content.split(pauseWord);\n                        if(content.length>0){\n                            // let errorReg = /\\s/;\n                            let validIndex = []\n                            for(let i = 0;i < content.length;i++){\n                                content[i] = content[i].trim();\n                                if(content[i]){\n                                    validIndex.push(i)\n                                }\n                            }\n                            if(validIndex.length>0){\n                                let validItem = []\n                                for(let i of validIndex){\n                                    validItem.push(content[i]);\n                                }\n                                let errorReg = /\\s/;\n                                if(key&&!errorReg.test(key)){\n                                    result[key] = validItem;\n                                }else{\n                                    defaultItem += validItem;\n                                }\n                            }\n                        }\n                    }\n                }\n                if(defaultItem.length>0){\n                    let defaultKey = \"未命名\";\n                    if(result.hasOwnProperty(defaultKey)){\n                        if(result[defaultKey] instanceof Array){\n                            result[defaultKey] += defaultItem;\n                        }else {\n                            result[defaultKey] = [result[defaultKey]] + defaultItem;\n                        }\n                    }else{\n                        result[defaultKey] = defaultItem;\n                    }\n                }\n                return result;\n            }\n        }\n    }\n</script>\n\n<style lang=\"less\">\n@import \"../assets/css/colors\";\n    .knowledge-graph-cy{\n      height: 100%;\n    }\n    #graph {\n        width: 100%;\n        height: 100%;\n        min-height: 500px;\n        cursor: move;\n    }\n\n    //菜单\n    .cy-context-menus-cxt-menu {\n        display: none;\n        z-index: 1001;\n        position:absolute;\n        border:1px solid @separator;\n        border-radius: 3px;\n        background-color: white;\n    }\n\n    //菜单条目\n    .cy-context-menus-cxt-menuitem {\n        border-radius: 3px;\n        display:block;\n        width: 100%;\n        padding: 7px 30px;\n        position:relative;\n        background-color: white;\n        font-size: 13px;\n        white-space:nowrap;\n        color: @myblack;\n        border: 0;\n        text-align: left;\n        img{\n            width: 15px;\n            height: 15px;\n        }\n    }\n\n    //菜单条目：enabled\n    .cy-context-menus-cxt-menuitem:enabled {}\n\n    //菜单条目：focus\n    .cy-context-menus-ctx-operation:focus {\n        //outline: none;\n    }\n\n    //菜单条目：hover\n    .cy-context-menus-cxt-menuitem:hover {\n        color: @theme;\n        text-decoration: none;\n        background-color: @hover;\n        background-image: none;\n        cursor: pointer;\n        border-radius: 0;\n    }\n\n    //？？\n    .cy-context-menus-cxt-menuitem[content]:before {\n        content:attr(content);\n    }\n\n    .cy-context-menus-divider {\n        border-bottom:1px solid @separator;\n    }\n\n    .cy-context-menus-submenu-indicator {\n        position: absolute;\n        right: 2px;\n        top: 50%;\n        transform: translateY(-50%);\n    }\n</style>\n"],"sourceRoot":""}]}